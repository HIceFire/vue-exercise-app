{
	"code": 0,
	"message": "ok",
	"data": [
		{
			"title": "Model complex workflows",
			"image": "https://www.gocd.io/assets/images/icons/go.cd_model-complex-workflows-9b181d3c.svg",
			"content": "With its parallel and sequential execution, GoCD can easily configure dependencies for fast feedback and on-demand deployment. Its fan-in/fan-out dependency management always does the \"right thing,\" avoiding spurious builds."
		},
		{
			"title": "Promote trusted artifacts",
			"image": "https://www.gocd.io/assets/images/icons/go.cd_promote-trusted-artifacts-5d5fc8ae.svg",
			"content": "Every pipeline instance is anchored to a particular changeset. GoCD makes it easy to pass once-built binaries between stages so you know exactly what's being deployed and that the binary has been tested."
		},
		{
			"title": "Clearly visualize your workflow",
			"image": "https://www.gocd.io/assets/images/icons/go.cd_see-how-things-really-work-d44e8c48.svg",
			"content": "GoCD's real power is in the visibility it provides over your end-to-end workflow. GoCD's Value Stream Map lets you track a change from commit to deploy at a glance. And when things go wrong, it's easy to see both the upstream cause and the downstream effects."
		},
		{
			"title": "Deploy any version, any time",
			"image": "https://www.gocd.io/assets/images/icons/go.cd_deploy-any-version-anytime-b7041220.svg",
			"content": "GoCD's manual triggers allow you to deploy any known good version of your application to wherever you like. This increases reliability of pushing to production, and empowers QA teams with self-service environments. And, if necessary, it's securable and auditable."
		},
		{
			"title": "Run and grok your tests",
			"image": "https://www.gocd.io/assets/images/icons/go.cd_run-and-grok-your-tests-f25e60ad.svg",
			"content": "Verification is a key piece of any deployment pipeline. GoCD will execute tests written in most languages or frameworks. GoCD's agent grid provides parallel and cross-platform execution. GoCD's test reporting will tell you in exactly which changeset and on which platform a test started breaking, which comes in extremely handy when fixing a complex broken build."
		}
	]
}
